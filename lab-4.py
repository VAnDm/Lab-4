"""
Математическое введение
Покажем, что локально в условиях данной задачи
применим алгоритм динамического программирования,
решающий задачу о рюкзаке

Заметим, что наш набор предметов можно представить,
как небольшое число "длинных" предметов (длины хотя бы 3)
и большое число "коротких" предметов (длины 1 или 2),
при этом, длинные предметы не превосходят размером
длину строки или столбца рюкзака соответственно.

Небольшим числом "длинных" предметов будем считать такое количество,
которое не превосходит число строк или столбцов 
(в зависимости от того, длину чего они непревосходят)
(далее, не умаляя общности, будем говорить про столбцы)

Докажем, что в таком случае мы сможем,
разместив некоторые (возможно все) "длинные" предметы в таблицу,
разрезать остаток на прямоугольники 1x2 оставив не более 1 клетки
Это будет означать, что при любом наборе предметов из исходного,
Мы сможем или взять его весь, или оставить не более 1 клетки пустой,
собрав рюкзак также, как мы могли бы сделать это, размещая предметы 
в линейный рюкзак.

Разместим слева по одному в столбец снизу все длинные предметы длины,
четность которой неравна четности столбца.
После них также разместим длинные предметы другой четности
Заметим, что в таком случае остатки первых столбцов слева
и остальных столбцов при делении на 2 различны.

Значит, если мы заполним все остатки столбцов вертикальнымми
прямоугольниками 1x2, то в верхней строке остаток образует
прямоугольник ширины 1, который разрезается на прямоугольники 1x2
с остатком не более 1
"""
"""
Обратим внимание, что в общем виде задача о заполнении тиблицы
m на n прямоугольниками ширины 1
не решается алгоритмом задачи о рюкзаке,
поэтому нам пришлось сделать очень грубое допущение о числе
длинных предметов, при котором в некотором роде теряется
смысл применения алгоритма задачи о рюкзаке.
"""
def task1(m, n, items, start):
    """
    Функция считает оптимальное заполнение рюкзака
    m на n предметами из items
    Подходит для решения основной лабораторной и первого допзадания
    (для допзадания вводим m = 7, n = 1)
    """
    items_s = sorted(items)
    num_items = len(items_s)
    W = n * m
    count = []
    for i in range(num_items + 1):
        count.append([0] * (W + 1))
    for i in range(num_items + 1):
        for j in range(W + 1):
            count[i][j] = [0, '.']
    for i in range(1, num_items + 1):
        for j in range(1, W + 1):
            if j >= items_s[i - 1][0]:
                if count[i - 1][j][0] > count[i - 1][j - items_s[i - 1][0]][0] + items[i - 1][1]:
                    count[i][j] = [count[i - 1][j][0], '.']
                else:
                    count[i][j] = [count[i - 1][j - items_s[i - 1][0]][0] + items[i - 1][1], '+']
                if i > 6  and j == 1:
                    print(count[i - 1][j][0], )
            else:
                count[i][j] = [count[i - 1][j][0], '.']
    summ = 0
    for i in items_s:
        summ += i[1]
    if summ >= 2 * count[num_items][W][0] + start:
        print("Impossible")
    else:
        ans = []
        j = W
        for i in range(num_items, 0, -1):
            if count[i][j][1] == '+':
                ans.append(items[i - 1])
                j = j - items[i - 1][0]
        print(2 * count[num_items][W][0] + start - summ)
        print(*ans)

def task2(n, m, items, start):
    """
    Функция делает полный перебор всех поднаборов и записывает подходящие
    """
    items_s = sorted(items)
    num_items = len(items_s)
    summ = 0
    answer = []
    for i in items_s:
        summ += i[1]
    W = n * m
    for i in range(2 ** num_items):
        group = []
        k = bin(i)[2::]
        if len(k) < num_items:
            k = f'{'0' * (num_items - len(k))}{k}'
        for j in range(num_items):
            if k[j] == '1':
                group.append(items_s[j])
        heavy = 0
        useful = 0
        for item in group:
            heavy += item[0]
            useful += item[1]
        if heavy <= W and 2 * useful + start > summ:
            answer.append(group)
    for i in answer:
        print(*i)
                              
if __name__ == "__main__":
    items = [(1, 5, 'i'), (1, 10, 'd'), 
             (1, 15, 'f'), (1, 15, 'k'), 
             (1, 25, 't'), (2, 15, 'a'),
             (2, 15, 'p'), (2, 20, 'c'),
             (2, 20, 'm'), (2, 20, 's'),
             (3, 20, 'x'), (3, 25, 'r')]
    task1(3, 3, items, 15)
    task1(7, 1, items, 15)
    task2(3, 3, items, 15)
    